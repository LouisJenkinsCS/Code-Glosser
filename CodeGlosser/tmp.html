<html><head><title></title><style>/*

github.com style (c) Vasily Polovnyov <vast@whiteants.net>

*/

.hljs {
  display: block;
  overflow-x: auto;
  padding: 0.5em;
  color: #333;
  background: #f8f8f8;
}

.hljs-comment,
.hljs-quote {
  color: #998;
  font-style: italic;
}

.hljs-keyword,
.hljs-selector-tag,
.hljs-subst {
  color: #333;
  font-weight: bold;
}

.hljs-number,
.hljs-literal,
.hljs-variable,
.hljs-template-variable,
.hljs-tag .hljs-attr {
  color: #008080;
}

.hljs-string,
.hljs-doctag {
  color: #d14;
}

.hljs-title,
.hljs-section,
.hljs-selector-id {
  color: #900;
  font-weight: bold;
}

.hljs-subst {
  font-weight: normal;
}

.hljs-type,
.hljs-class .hljs-title {
  color: #458;
  font-weight: bold;
}

.hljs-tag,
.hljs-name,
.hljs-attribute {
  color: #000080;
  font-weight: normal;
}

.hljs-regexp,
.hljs-link {
  color: #009926;
}

.hljs-symbol,
.hljs-bullet {
  color: #990073;
}

.hljs-built_in,
.hljs-builtin-name {
  color: #0086b3;
}

.hljs-meta {
  color: #999;
  font-weight: bold;
}

.hljs-deletion {
  background: #fdd;
}

.hljs-addition {
  background: #dfd;
}

.hljs-emphasis {
  font-style: italic;
}

.hljs-strong {
  font-weight: bold;
}</style><style>.note {
  display: inline;
  position: relative;
  background-color: yellow;
}

.note:hover:after {
  background: #333;
  background: rgba(0,0,0,.8);
  border-radius: 5px;
  bottom: 26px;
  white-space: pre-wrap;
  color: #fff;
  content: attr(msg);
  left: 20%;
  padding: 5px 15px;
  position: absolute;
  z-index: 98;
  width:500px;
  display:block;
  word-wrap: normal;
}

.note:hover:before{
  border:solid;
  border-color: #333 transparent;
  border-width: 6px 6px 0 6px;
  bottom: 20px;
  content: "";
  left: 50%;
  position: absolute;
  display:block;
  z-index: 99;
}</style><meta charset="UTF-8"></head><body><pre><code><span class="hljs-keyword">package</span> combined_testing

<span class="hljs-keyword">import</span> (
	<span class="hljs-string">"math/rand"</span>
	<span class="hljs-string">"runtime"</span>
	<span class="hljs-string">"settings"</span>
	<span class="hljs-string">"strconv"</span>
	<span class="hljs-string">"sync"</span>
	<span class="hljs-string">"testing"</span>
	<span class="hljs-string">"time"</span>

	cmap <span class="hljs-string">"github.com/streamrail/concurrent-map"</span>
	gotomic <span class="hljs-string">"github.com/zond/gotomic"</span>
)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkConcurrentCombined</span><span class="hljs-params">(b *testing.B)</span></span> {
	cmap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int64</span>]settings.Unused, settings.COMBINED_KEY_RANGE, runtime.GOMAXPROCS(<span class="hljs-number">0</span>))

	<span class="note" msg="Create a better way to reserve space ahead of time. As well, make it dynamic enough so that it can be benchmarked from empty to test resizing overhead as well."><span class="hljs-comment">// Fill map to reduce overhead of resizing</span></span>
	<span class="note" msg="Create a better way to reserve space ahead of time. As well, make it dynamic enough so that it can be benchmarked from empty to test resizing overhead as well."><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">int64</span>(<span class="hljs-number">0</span>); i &lt; settings.COMBINED_KEY_RANGE; i++ {</span>
		<span class="note" msg="Create a better way to reserve space ahead of time. As well, make it dynamic enough so that it can be benchmarked from empty to test resizing overhead as well.">cmap[i] = settings.UNUSED</span>
	<span class="note" msg="Create a better way to reserve space ahead of time. As well, make it dynamic enough so that it can be benchmarked from empty to test resizing overhead as well.">}</span>
	<span class="note" msg="Create a better way to reserve space ahead of time. As well, make it dynamic enough so that it can be benchmarked from empty to test resizing overhead as well."><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">int64</span>(<span class="hljs-number">0</span>); i &lt; settings.COMBINED_KEY_RANGE; i++ {</span>
		<span class="note" msg="Create a better way to reserve space ahead of time. As well, make it dynamic enough so that it can be benchmarked from empty to test resizing overhead as well."><span class="hljs-built_in">delete</span>(cmap, i)</span>
	<span class="note" msg="Create a better way to reserve space ahead of time. As well, make it dynamic enough so that it can be benchmarked from empty to test resizing overhead as well.">}</span>

	b.ResetTimer()
	b.RunParallel(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(pb *testing.PB)</span></span> {
		rng := rand.New(rand.NewSource(time.Now().UTC().UnixNano()))

		<span class="hljs-keyword">for</span> pb.Next() {
			randRatio := rng.Float64()
			randNum := rng.Int63n(settings.COMBINED_KEY_RANGE)
			<span class="hljs-keyword">switch</span> {
			<span class="hljs-comment">// 0 &lt;= randRatio &lt; .25 -&gt; Insert</span>
			<span class="hljs-keyword">case</span> randRatio &lt; settings.COMBINED_FAIR_RATIO:
				cmap[randNum] = settings.UNUSED
			<span class="hljs-comment">// .25 &lt;= randRatio &lt; .5 -&gt; Delete</span>
			<span class="hljs-keyword">case</span> randRatio &lt; <span class="hljs-number">2</span>*settings.COMBINED_FAIR_RATIO:
				<span class="hljs-built_in">delete</span>(cmap, randNum)
			<span class="hljs-comment">// .5 &lt;= randRatio &lt; .75 -&gt; Lookup</span>
			<span class="hljs-keyword">case</span> randRatio &lt; <span class="hljs-number">3</span>*settings.COMBINED_FAIR_RATIO:
				tmp := cmap[randNum]
				tmp++
			<span class="hljs-comment">// .75 &lt;= randRatio &lt; 1 -&gt; Iterate</span>
			<span class="hljs-keyword">default</span>:
				<span class="hljs-comment">// Each iteration counts as an operation (as it calls mapiternext)</span>
				<span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> cmap {
					k++
					v++
				}
			}
		}
	})
	b.StopTimer()
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkStreamrailConcurrentCombined</span><span class="hljs-params">(b *testing.B)</span></span> {
	scmap := cmap.New()

	<span class="hljs-comment">// Fill map to reduce overhead of resizing</span>
	<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">int64</span>(<span class="hljs-number">0</span>); i &lt; settings.COMBINED_KEY_RANGE; i++ {
		scmap.Set(strconv.FormatInt(i, <span class="hljs-number">10</span>), settings.UNUSED)
	}
	<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">int64</span>(<span class="hljs-number">0</span>); i &lt; settings.COMBINED_KEY_RANGE; i++ {
		scmap.Remove(strconv.FormatInt(i, <span class="hljs-number">10</span>))
	}

	b.ResetTimer()
	b.RunParallel(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(pb *testing.PB)</span></span> {
		rng := rand.New(rand.NewSource(time.Now().UTC().UnixNano()))

		<span class="hljs-keyword">for</span> pb.Next() {
			randRatio := rng.Float64()
			randNum := rng.Int63n(settings.COMBINED_KEY_RANGE)
			<span class="hljs-keyword">switch</span> {
			<span class="hljs-comment">// 0 &lt;= randRatio &lt; .25 -&gt; Insert</span>
			<span class="hljs-keyword">case</span> randRatio &lt; settings.COMBINED_FAIR_RATIO:
				scmap.Set(strconv.FormatInt(randNum, <span class="hljs-number">10</span>), settings.UNUSED)
			<span class="hljs-comment">// .25 &lt;= randRatio &lt; .5 -&gt; Delete</span>
			<span class="hljs-keyword">case</span> randRatio &lt; <span class="hljs-number">2</span>*settings.COMBINED_FAIR_RATIO:
				scmap.Remove(strconv.FormatInt(randNum, <span class="hljs-number">10</span>))
			<span class="hljs-comment">// .5 &lt;= randRatio &lt; .75 -&gt; Lookup</span>
			<span class="hljs-keyword">case</span> randRatio &lt; <span class="hljs-number">3</span>*settings.COMBINED_FAIR_RATIO:
				scmap.Get(strconv.FormatInt(randNum, <span class="hljs-number">10</span>))
			<span class="hljs-comment">// .75 &lt;= randRatio &lt; 1 -&gt; Iterate</span>
			<span class="hljs-keyword">default</span>:
				<span class="hljs-comment">// Each iteration counts as an operation (as it calls mapiternext)</span>
				<span class="hljs-keyword">for</span> item := <span class="hljs-keyword">range</span> scmap.Iter() {
					_ = item.Key
					_ = item.Val
				}
			}
		}
	})
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkGotomicConcurrentCombined</span><span class="hljs-params">(b *testing.B)</span></span> {
	gcmap := gotomic.NewHash()

	<span class="hljs-comment">// Fill map to reduce overhead of resizing</span>
	<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">int64</span>(<span class="hljs-number">0</span>); i &lt; settings.COMBINED_KEY_RANGE; i++ {
		gcmap.Put(gotomic.IntKey(<span class="hljs-keyword">int</span>(i)), settings.UNUSED)
	}
	<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">int64</span>(<span class="hljs-number">0</span>); i &lt; settings.COMBINED_KEY_RANGE; i++ {
		gcmap.Delete(gotomic.IntKey(<span class="hljs-keyword">int</span>(i)))
	}

	b.ResetTimer()
	b.RunParallel(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(pb *testing.PB)</span></span> {
		rng := rand.New(rand.NewSource(time.Now().UTC().UnixNano()))

		<span class="hljs-keyword">for</span> pb.Next() {
			randRatio := rng.Float64()
			randNum := rng.Int63n(settings.COMBINED_KEY_RANGE)
			<span class="hljs-keyword">switch</span> {
			<span class="hljs-comment">// 0 &lt;= randRatio &lt; .25 -&gt; Insert</span>
			<span class="hljs-keyword">case</span> randRatio &lt; settings.COMBINED_FAIR_RATIO:
				gcmap.Put(gotomic.IntKey(<span class="hljs-keyword">int</span>(randNum)), settings.UNUSED)
			<span class="hljs-comment">// .25 &lt;= randRatio &lt; .5 -&gt; Delete</span>
			<span class="hljs-keyword">case</span> randRatio &lt; <span class="hljs-number">2</span>*settings.COMBINED_FAIR_RATIO:
				gcmap.Delete(gotomic.IntKey(<span class="hljs-keyword">int</span>(randNum)))
			<span class="hljs-comment">// .5 &lt;= randRatio &lt; .75 -&gt; Lookup</span>
			<span class="hljs-keyword">case</span> randRatio &lt; <span class="hljs-number">3</span>*settings.COMBINED_FAIR_RATIO:
				gcmap.Get(gotomic.IntKey(<span class="hljs-keyword">int</span>(randNum)))
			<span class="hljs-comment">// .75 &lt;= randRatio &lt; 1 -&gt; Iterate</span>
			<span class="hljs-keyword">default</span>:
				<span class="hljs-comment">// Each iteration counts as an operation (as it calls mapiternext)</span>
				gcmap.Each(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(k gotomic.Hashable, v gotomic.Thing)</span> <span class="hljs-title">bool</span></span> {
					_ = k
					_ = v
					<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
				})
			}
		}
	})
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkSynchronizedCombined</span><span class="hljs-params">(b *testing.B)</span></span> {
	smap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int64</span>]settings.Unused, settings.COMBINED_KEY_RANGE)
	<span class="hljs-keyword">var</span> mtx sync.Mutex

	<span class="hljs-comment">// Fill map to reduce overhead of resizing</span>
	<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">int64</span>(<span class="hljs-number">0</span>); i &lt; settings.COMBINED_KEY_RANGE; i++ {
		smap[i] = settings.UNUSED
	}
	<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">int64</span>(<span class="hljs-number">0</span>); i &lt; settings.COMBINED_KEY_RANGE; i++ {
		<span class="hljs-built_in">delete</span>(smap, i)
	}

	b.ResetTimer()
	b.RunParallel(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(pb *testing.PB)</span></span> {
		rng := rand.New(rand.NewSource(time.Now().UTC().UnixNano()))

		<span class="hljs-keyword">for</span> pb.Next() {
			randRatio := rng.Float64()
			randNum := rng.Int63n(settings.COMBINED_KEY_RANGE)
			<span class="hljs-keyword">switch</span> {
			<span class="hljs-comment">// 0 &lt;= randRatio &lt; .25 -&gt; Insert</span>
			<span class="hljs-keyword">case</span> randRatio &lt; settings.COMBINED_FAIR_RATIO:
				mtx.Lock()
				smap[randNum] = settings.UNUSED
				mtx.Unlock()
			<span class="hljs-comment">// .25 &lt;= randRatio &lt; .5 -&gt; Delete</span>
			<span class="hljs-keyword">case</span> randRatio &lt; <span class="hljs-number">2</span>*settings.COMBINED_FAIR_RATIO:
				mtx.Lock()
				<span class="hljs-built_in">delete</span>(smap, randNum)
				mtx.Unlock()
			<span class="hljs-comment">// .5 &lt;= randRatio &lt; .75 -&gt; Lookup</span>
			<span class="hljs-keyword">case</span> randRatio &lt; <span class="hljs-number">3</span>*settings.COMBINED_FAIR_RATIO:
				mtx.Lock()
				tmp := smap[randNum]
				mtx.Unlock()
				tmp++
			<span class="hljs-comment">// .75 &lt;= randRatio &lt; 1 -&gt; Iterate</span>
			<span class="hljs-keyword">default</span>:
				mtx.Lock()
				<span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> smap {
					k++
					v++
				}
				mtx.Unlock()
			}
		}
	})
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkReaderWriterCombined</span><span class="hljs-params">(b *testing.B)</span></span> {
	rwmap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int64</span>]settings.Unused, settings.COMBINED_KEY_RANGE)
	<span class="hljs-keyword">var</span> mtx sync.RWMutex

	<span class="hljs-comment">// Fill map to reduce overhead of resizing</span>
	<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">int64</span>(<span class="hljs-number">0</span>); i &lt; settings.COMBINED_KEY_RANGE; i++ {
		rwmap[i] = settings.UNUSED
	}
	<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">int64</span>(<span class="hljs-number">0</span>); i &lt; settings.COMBINED_KEY_RANGE; i++ {
		<span class="hljs-built_in">delete</span>(rwmap, i)
	}

	b.ResetTimer()
	b.RunParallel(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(pb *testing.PB)</span></span> {
		rng := rand.New(rand.NewSource(time.Now().UTC().UnixNano()))

		<span class="hljs-keyword">for</span> pb.Next() {
			randRatio := rng.Float64()
			randNum := rng.Int63n(settings.COMBINED_KEY_RANGE)
			<span class="hljs-keyword">switch</span> {
			<span class="hljs-comment">// 0 &lt;= randRatio &lt; .25 -&gt; Insert</span>
			<span class="hljs-keyword">case</span> randRatio &lt; settings.COMBINED_FAIR_RATIO:
				mtx.Lock()
				rwmap[randNum] = settings.UNUSED
				mtx.Unlock()
			<span class="hljs-comment">// .25 &lt;= randRatio &lt; .5 -&gt; Delete</span>
			<span class="hljs-keyword">case</span> randRatio &lt; <span class="hljs-number">2</span>*settings.COMBINED_FAIR_RATIO:
				mtx.Lock()
				<span class="hljs-built_in">delete</span>(rwmap, randNum)
				mtx.Unlock()
			<span class="hljs-comment">// .5 &lt;= randRatio &lt; .75 -&gt; Lookup</span>
			<span class="hljs-keyword">case</span> randRatio &lt; <span class="hljs-number">3</span>*settings.COMBINED_FAIR_RATIO:
				mtx.RLock()
				tmp := rwmap[randNum]
				mtx.RUnlock()
				tmp++
			<span class="hljs-comment">// .75 &lt;= randRatio &lt; 1 -&gt; Iterate</span>
			<span class="hljs-keyword">default</span>:
				mtx.RLock()
				<span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> rwmap {
					k++
					v++
				}
				mtx.RUnlock()
			}
		}
	})
}</code></pre></body></html>